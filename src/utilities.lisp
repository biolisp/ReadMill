;;;
;;; Copyright (C) 2010 Genome Research Ltd. All rights reserved.
;;;
;;; This file is part of readmill.
;;;
;;; This program is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
;;;

(in-package :uk.ac.sanger.readmill)

(defvar *readmill-name* "ReadMill")
(defvar *readmill-version* "0.0.4"
  "The version number of the ReadMill application.")

(deftype quality-score ()
  '(integer 0 100))

(defun any (&rest fns)
  "Returns a new function that takes one optional argument. When the
argument is non-null, it returns T if a call to any of FNS with that
argument would return T."
  (lambda (&optional arg)
    (and arg (some (lambda (fn)
                     (funcall fn arg)) fns))))

(defun peek-alignment (bam)
  "Returns the next alignment in BAM stream, or NIL."
  (let ((pos (bgzf-tell bam)))
    (prog1
        (read-alignment bam)
      (bgzf-seek bam pos))))

(defun peek-read-length (bam)
  "Returns the length of the next read BAM stream."
  (let ((aln (peek-alignment bam)))
    (if aln
        (read-length aln)
        (error 'invalid-operation-error
               :format-control (txt "cannot peek read length;"
                                    "reached end of stream")))))

(defun decode-phred-quality (c)
  "Returns the Phred quality score encoded by the character C."
  (- (char-code c) 33))

(defun vector-mean (sums count)
  (flet ((mean (sum)
           (float (/ sum count))))
    (let ((means (make-array (length sums) :element-type 'float
                             :initial-element 0.f0)))
      (map-into means #'mean sums))))

(defun plot-per-base (plot-filespec values sample-name y-label)
  (plot-png nil values plot-filespec :title sample-name
            :x-label "Base position" :y-label y-label))

(defun plot-png (x y png-filespec &key title x-label y-label)
  "Plots X against Y and saves the result to file PNG-FILESPEC. The
plot is annotated with TITLE, X-LABEL and Y-LABEL."
  (let ((plotter (dxr:run-gnuplot))
        (plot (make-instance
               'dxr:2d-plot
               :title title
               :x-axis (make-instance 'dxr:axis :label x-label :position :x)
               :y-axis (make-instance 'dxr:axis :label y-label :position :y)
               :series (make-instance 'dxr:xy-series
                                      :x-values (or x (iota (length y)))
                                      :y-values y
                                      :style '(:linespoints
                                               :smooth
                                               :csplines)))))
    (dxr:draw-plot plotter plot :terminal :png :output png-filespec)
    (dxr:stop-gnuplot plotter)))

(defun previous-program (header)
  "Returns the previous program to be run on the data, if such can be
deduced unambiguously. If there are more than one leaf programs in the
tree, returns NIL."
  (let ((pp (last-programs header)))
    (when (endp (rest pp))
      (first pp))))

(defun fake-bam-file (filespec &key (num-refs 10) (ref-length 1000)
                      (read-step 50) (read-length 50) seq-fn  qual-fn)
  "Creates a fake BAM file containing regular reads. The files
generated by this function are extremely regular and not intended to
model any biology. Their purpose is to serve as test cases."
  (flet ((fake-ref-meta (n)
           (loop
              for i from 0 below n
              collect (list i (format nil "ref_~d" i) ref-length)))
         (fake-sq-records (ref-meta)
           (loop
              for m in ref-meta
              collect (sq-record (second m) (third m))))
         (fake-rg-records (n)
           (loop
              for i from 0 below n
              collect (rg-record (format nil "~d" i)
                                 (format nil "sample.~d" i))))
         (fake-seq (length)
           (map-into (make-string length) (lambda ()
                                            (ecase (random 4)
                                              (0 #\a)
                                              (1 #\c)
                                              (2 #\g)
                                              (3 #\t)))))
         (fake-qual (length)
           (make-string length :initial-element #\B)))
    (let* ((seq-fn (or seq-fn #'fake-seq))
           (qual-fn (or qual-fn #'fake-qual))
           (ref-meta (fake-ref-meta num-refs))
           (header (with-output-to-string (s)
                     (write-sam-header
                      (apply #'list
                             (hd-record :version "1.3" :sort-order :coordinate)
                             (concatenate 'list
                                          (fake-sq-records ref-meta)
                                          (fake-rg-records num-refs))) s))))
      (with-bam (out (header num-refs ref-meta) filespec :direction :output
                     :if-exists :overwrite :if-does-not-exist :create)
        (do ((ref-num 0 (1+ ref-num)))
            ((= ref-num num-refs))
          (do ((read-num 0 (1+ read-num))
               (read-pos 0 (+ read-pos read-step)))
              ((>= read-pos ref-length))
            (consume
             out (make-alignment-record
                  (format nil "read_~6,'0d.~6,'0d" ref-num read-num)
                  (funcall seq-fn read-length)
                  (flag-bits 0 :not-sequenced-pair :query-mapped)
                  :quality-str (funcall qual-fn read-length)
                  :reference-id ref-num
                  :alignment-pos read-pos
                  :mapping-quality 20
                  :cigar (list (cons :m read-length))
                  :tag-values (pairlis
                               '(:rg)
                               (list (format nil "~d" ref-num))))))))
      filespec)))
